/** @file   geometry_bvh.cu
 *  @author Fatemeh Salehi
 */

#include <neural-graphics-primitives/common_host.h>
#include <neural-graphics-primitives/geometry_bvh.cuh>

#include <tiny-cuda-nn/gpu_memory.h>

#include <stack>

#ifdef NGP_OPTIX
#  include <optix.h>
#  include <optix_stubs.h>
#  include <optix_function_table_definition.h>
#  include <optix_stack_size.h>

// Custom optix toolchain stuff
// Todo: have another raytrace optix file 
#  include "optix/raytrace.h"

#  include "optix/program.h"

// Compiled optix program PTX generated by cmake and wrapped in a C
// header by bin2c.
namespace optix_ptx {
	#include <optix_ptx.h>
}
#endif //NGP_OPTIX

namespace ngp {

constexpr float MAX_DIST = 10.0f;

#ifdef NGP_OPTIX
OptixDeviceContext g_optix;

namespace optix {
	bool initialize() {
		static bool ran_before = false;
		static bool is_optix_initialized = false;
		if (ran_before) {
			return is_optix_initialized;
		}

		ran_before = true;

		// Initialize CUDA with a no-op call to the the CUDA runtime API
		CUDA_CHECK_THROW(cudaFree(nullptr));

		try {
			// Initialize the OptiX API, loading all API entry points
			OPTIX_CHECK_THROW(optixInit());

			// Specify options for this context. We will use the default options.
			OptixDeviceContextOptions options = {};

			// Associate a CUDA context (and therefore a specific GPU) with this
			// device context
			CUcontext cuCtx = 0; // NULL means take the current active context

			OPTIX_CHECK_THROW(optixDeviceContextCreate(cuCtx, &options, &g_optix));
		} catch (std::exception& e) {
			tlog::warning() << "OptiX failed to initialize: " << e.what();
			return false;
		}

		is_optix_initialized = true;
		return true;
	}

	class Gas {
	public:
		Gas(const GPUMemory<GeometryBvhNode>& nodes, OptixDeviceContext optix, cudaStream_t stream) {
			// Specify options for the build. We use default options for simplicity.
			OptixAccelBuildOptions accel_options = {};
			accel_options.buildFlags = OPTIX_BUILD_FLAG_NONE;
			accel_options.operation = OPTIX_BUILD_OPERATION_BUILD;

			// Populate the build input struct with our triangle data as well as
			// information about the sizes and types of our data
			const uint32_t triangle_input_flags[1] = { OPTIX_GEOMETRY_FLAG_NONE };
			OptixBuildInput triangle_input = {};

			// should be bb
			CUdeviceptr d_nodes = (CUdeviceptr)(uintptr_t)&nodes.data()->bb;

			// not sure!!
			node_input.type = OPTIX_BUILD_INPUT_TYPE_CUSTOM_PRIMITIVES;
			node_input.aabbArray.aabbBuffers = &d_nodes;	// build a new buffer for the bounding boxes
        	node_input.aabbArray.numPrimitives = (uint32_t)nodes.size();
        	node_input.aabbArray.flags = node_input_flags;
        	node_input.aabbArray.numSbtRecords = 1;

			// Query OptiX for the memory requirements for our GAS
			OptixAccelBufferSizes gas_buffer_sizes;
			OPTIX_CHECK_THROW(optixAccelComputeMemoryUsage(optix, &accel_options, &node_input, 1, &gas_buffer_sizes));

			// Allocate device memory for the scratch space buffer as well
			// as the GAS itself
			GPUMemory<char> gas_tmp_buffer{gas_buffer_sizes.tempSizeInBytes};
			m_gas_gpu_buffer.resize(gas_buffer_sizes.outputSizeInBytes);

			OPTIX_CHECK_THROW(optixAccelBuild(
				optix,
				stream,
				&accel_options,
				&node_input,
				1,           // num build inputs
				(CUdeviceptr)(uintptr_t)gas_tmp_buffer.data(),
				gas_buffer_sizes.tempSizeInBytes,
				(CUdeviceptr)(uintptr_t)m_gas_gpu_buffer.data(),
				gas_buffer_sizes.outputSizeInBytes,
				&m_gas_handle, // Output handle to the struct
				nullptr,       // emitted property list
				0              // num emitted properties
			));
		}

		OptixTraversableHandle handle() const {
			return m_gas_handle;
		}

	private:
		OptixTraversableHandle m_gas_handle;
		GPUMemory<char> m_gas_gpu_buffer;
	};
}
#endif //NGP_OPTIX

__global__ void raytrace_kernel(uint32_t n_elements, vec3* __restrict__ positions, vec3* __restrict__ directions, const TriangleBvhNode* __restrict__ nodes, const Triangle* __restrict__ triangles);

struct DistAndIdx {
	float dist;
	uint32_t idx;

	// Sort in descending order!
	__host__ __device__ bool operator<(const DistAndIdx& other) {
		return dist < other.dist;
	}
};

template <typename T>
__host__ __device__ void inline compare_and_swap(T& t1, T& t2) {
	if (t1 < t2) {
		T tmp{t1}; t1 = t2; t2 = tmp;
	}
}

// Sorting networks from http://users.telenet.be/bertdobbelaere/SorterHunter/sorting_networks.html#N4L5D3
template <uint32_t N, typename T>
__host__ __device__ void sorting_network(T values[N]) {
	static_assert(N <= 8, "Sorting networks are only implemented up to N==8");
	if (N <= 1) {
		return;
	} else if (N == 2) {
		compare_and_swap(values[0], values[1]);
	} else if (N == 3) {
		compare_and_swap(values[0], values[2]);
		compare_and_swap(values[0], values[1]);
		compare_and_swap(values[1], values[2]);
	} else if (N == 4) {
		compare_and_swap(values[0], values[2]);
		compare_and_swap(values[1], values[3]);
		compare_and_swap(values[0], values[1]);
		compare_and_swap(values[2], values[3]);
		compare_and_swap(values[1], values[2]);
	} else if (N == 5) {
		compare_and_swap(values[0], values[3]);
		compare_and_swap(values[1], values[4]);

		compare_and_swap(values[0], values[2]);
		compare_and_swap(values[1], values[3]);

		compare_and_swap(values[0], values[1]);
		compare_and_swap(values[2], values[4]);

		compare_and_swap(values[1], values[2]);
		compare_and_swap(values[3], values[4]);

		compare_and_swap(values[2], values[3]);
	} else if (N == 6) {
		compare_and_swap(values[0], values[5]);
		compare_and_swap(values[1], values[3]);
		compare_and_swap(values[2], values[4]);

		compare_and_swap(values[1], values[2]);
		compare_and_swap(values[3], values[4]);

		compare_and_swap(values[0], values[3]);
		compare_and_swap(values[2], values[5]);

		compare_and_swap(values[0], values[1]);
		compare_and_swap(values[2], values[3]);
		compare_and_swap(values[4], values[5]);

		compare_and_swap(values[1], values[2]);
		compare_and_swap(values[3], values[4]);
	} else if (N == 7) {
		compare_and_swap(values[0], values[6]);
		compare_and_swap(values[2], values[3]);
		compare_and_swap(values[4], values[5]);

		compare_and_swap(values[0], values[2]);
		compare_and_swap(values[1], values[4]);
		compare_and_swap(values[3], values[6]);

		compare_and_swap(values[0], values[1]);
		compare_and_swap(values[2], values[5]);
		compare_and_swap(values[3], values[4]);

		compare_and_swap(values[1], values[2]);
		compare_and_swap(values[4], values[6]);

		compare_and_swap(values[2], values[3]);
		compare_and_swap(values[4], values[5]);

		compare_and_swap(values[1], values[2]);
		compare_and_swap(values[3], values[4]);
		compare_and_swap(values[5], values[6]);
	} else if (N == 8) {
		compare_and_swap(values[0], values[2]);
		compare_and_swap(values[1], values[3]);
		compare_and_swap(values[4], values[6]);
		compare_and_swap(values[5], values[7]);

		compare_and_swap(values[0], values[4]);
		compare_and_swap(values[1], values[5]);
		compare_and_swap(values[2], values[6]);
		compare_and_swap(values[3], values[7]);

		compare_and_swap(values[0], values[1]);
		compare_and_swap(values[2], values[3]);
		compare_and_swap(values[4], values[5]);
		compare_and_swap(values[6], values[7]);

		compare_and_swap(values[2], values[4]);
		compare_and_swap(values[3], values[5]);

		compare_and_swap(values[1], values[4]);
		compare_and_swap(values[3], values[6]);

		compare_and_swap(values[1], values[2]);
		compare_and_swap(values[3], values[4]);
		compare_and_swap(values[5], values[6]);
	}
}

template <uint32_t BRANCHING_FACTOR>
class GeometryBvhWithBranchingFactor : public GeometryBvh {
public:
	__host__ __device__ static std::pair<int, float> ray_intersect(const vec3& ro, const vec3& rd, const GeometryBvh* __restrict__ bvhnodes) {
		FixedIntStack query_stack;
		query_stack.push(0);

		float mint = MAX_DIST;
		int shortest_idx = -1;

		while (!query_stack.empty()) {
			int idx = query_stack.pop();

			const GeometryBvhNode& node = bvhnodes[idx];
			
			float t = node.bb.ray_intersect(ro, rd).x;

        	// If the ray intersects the bounding box of the node
			if(t < std::numeric_limits<float>::max())
			{	

				// If it's a leaf node
				if (node.left_idx < 0) {
					intersectedRays.push_back({ro, rd});
                	// Perform the appropriate intersection test based on the type
                	if (node.type == NodeType::MESH) {
						// Todo: Implement ray_intersect for mesh
						// most probably using the triangle intersection returning min of traingle intersections
                	    t = node.data.mesh.ray_intersect(ro, rd);
                	} else if (node.type == NodeType::NERF) {
						// Todo: Implement ray_intersect for nerf
						// maybe just return the ray intersection with the bounding box => do nothing here
                	    // t = node.data.nerf.ray_intersect(ro, rd);
                	}
                	
					if (t < mint) {
                	    mint = t;
                	    shortest_idx = idx;
                	}
            	} 
            	// If it's not a leaf node
				// same as trinagle bvh
				else {
					DistAndIdx children[BRANCHING_FACTOR];

					uint32_t first_child = node.left_idx;

					NGP_PRAGMA_UNROLL
					for (uint32_t i = 0; i < BRANCHING_FACTOR; ++i) {
						children[i] = {bvhnodes[i+first_child].bb.ray_intersect(ro, rd).x, i+first_child};
					}

					sorting_network<BRANCHING_FACTOR>(children);

					// pushes the indices ofchildren with the closest bounding boxes (intersect with the ray) to the query stack
					NGP_PRAGMA_UNROLL
					for (uint32_t i = 0; i < BRANCHING_FACTOR; ++i) {
						if (children[i].dist < mint) {
							query_stack.push(children[i].idx);
						}
					}
				}
			}
		}

		return {shortest_idx, mint};
	}

	
	
	void ray_trace_gpu(uint32_t n_elements, vec3* gpu_positions, vec3* gpu_directions, const GeometryBvhNode* m_nodes_gpu, cudaStream_t stream) override {
#ifdef NGP_OPTIX
		if (m_optix.available) {
			// creating params for raytrace with ray_origins, ray_directions, and triangles and OptixTraversableHandle geometry
			// dimensions of the launch grid
			// first copied from host memory to device memory
			// second Optix kernel is launched 
			// Todo: Implement optix raytrace for ?
			m_optix.raytrace->invoke({gpu_positions, gpu_directions, gpu_triangles, m_optix.gas->handle()}, {n_elements, 1, 1}, stream);	
		} else
#endif //NGP_OPTIX
		{
			linear_kernel(raytrace_kernel, 0, stream,
				n_elements,
				gpu_positions,
				gpu_directions,
				m_nodes_gpu.data()
			);
			
		}
	}

	void build(std::vector<GeometryBvhNode>& nodes, uint32_t n_primitives_per_leaf) override {
		m_nodes.clear();

		// Root
		m_nodes.emplace_back();
		m_nodes.front().bb = BoundingBox(nodes.data(), nodes.data() + nodes.size());

		struct BuildNode {
			int node_idx;
			std::vector<GeometryBvhNode>::iterator begin;
			std::vector<GeometryBvhNode>::iterator end;
		};

		std::stack<BuildNode> build_stack;
		build_stack.push({0, std::begin(nodes), std::end(nodes)});

		while (!build_stack.empty()) {
			const BuildNode& curr = build_stack.top();
			size_t node_idx = curr.node_idx;

			std::array<BuildNode, BRANCHING_FACTOR> c;
			c[0].begin = curr.begin;
			c[0].end = curr.end;

			build_stack.pop();

			// Partition the triangles into the children
			int number_c = 1;
			while (number_c < BRANCHING_FACTOR) {
				for (int i = number_c - 1; i >= 0; --i) {
					auto& child = c[i];

					// Choose axis with maximum standard deviation
					vec3 mean = vec3(0.0f);
					for (auto it = child.begin; it != child.end; ++it) {
						mean += it->bb.center(); // In the traingle bvh they use centroid instead of center!
					}
					mean /= (float)std::distance(child.begin, child.end);

					vec3 var = vec3(0.0f);
					for (auto it = child.begin; it != child.end; ++it) {
						vec3 diff = it->bb.center() - mean;
						var += diff * diff;
					}
					var /= (float)std::distance(child.begin, child.end);

					float max_val = max(var);
					int axis = var.x == max_val ? 0 : (var.y == max_val ? 1 : 2);

					auto m = child.begin + std::distance(child.begin, child.end)/2;
					std::nth_element(child.begin, m, child.end, [&](const GeometryBvhNode& node1, const GeometryBvhNode& node2) { return node1.bb.center(axis) < node2.bb.center(axis); });

					c[i*2].begin = c[i].begin;
					c[i*2+1].end = c[i].end;
					c[i*2].end = c[i*2+1].begin = m;
				}

				number_c *= 2;
			}

			// Create next build nodes
			m_nodes[node_idx].left_idx = (int)m_nodes.size();
			for (uint32_t i = 0; i < BRANCHING_FACTOR; ++i) {
				auto& child = c[i];
				assert(child.begin != child.end);
				child.node_idx = (int)m_nodes.size();

				m_nodes.emplace_back();
				m_nodes.back().bb = BoundingBox(&*child.begin, &*child.end);

				if (std::distance(child.begin, child.end) <= n_primitives_per_leaf) {
					m_nodes.back().left_idx = -(int)std::distance(std::begin(nodes), child.begin)-1;
					m_nodes.back().right_idx = -(int)std::distance(std::begin(nodes), child.end)-1;
				} else {
					build_stack.push(child);
				}
			}
			m_nodes[node_idx].right_idx = (int)m_nodes.size();
		}

		m_nodes_gpu.resize_and_copy_from_host(m_nodes);

		tlog::success() << "Built GeometryBvh: nodes=" << m_nodes.size();
	}

	void build_optix(const GPUMemory<GeometryBvhNode>& nodes, cudaStream_t stream) override {
#ifdef NGP_OPTIX
		m_optix.available = optix::initialize();
		if (m_optix.available) {
			m_optix.gas = std::make_unique<optix::Gas>(nodes, g_optix, stream);	// Todo: Implement optix::Gas
			m_optix.raytrace = std::make_unique<optix::Program<Raytrace>>((const char*)optix_ptx::raytrace_ptx, sizeof(optix_ptx::raytrace_ptx), g_optix);
			tlog::success() << "Built OptiX GAS and shaders";
		} else {
			tlog::warning() << "Falling back to slower GeometryBvh::ray_intersect.";
		}
#else //NGP_OPTIX
		tlog::warning() << "OptiX was not built. Falling back to slower GeometryBvh::ray_intersect.";
#endif //NGP_OPTIX
	}

	GeometryBvhWithBranchingFactor() {}

private:
#ifdef NGP_OPTIX
	struct {
		std::unique_ptr<optix::Gas> gas;
		std::unique_ptr<optix::Program<Raytrace>> raytrace;
		bool available = true;
	} m_optix;
#endif //NGP_OPTIX
};

using GeometryBvh4 = GeometryBvhWithBranchingFactor<4>;

std::unique_ptr<GeometryBvh> GeometryBvh::make() {
	return std::unique_ptr<GeometryBvh>(new GeometryBvh4());
}

__global__ void raytrace_kernel(uint32_t n_elements, vec3* __restrict__ positions, vec3* __restrict__ directions, const GeometryBvh* __restrict__ bvh) {
	uint32_t i = blockIdx.x * blockDim.x + threadIdx.x;	//index i of the current thread.
	if (i >= n_elements) return;

	auto pos = positions[i];
	auto dir = directions[i];

	auto p = GeometryBvh4::ray_intersect(pos, dir, bvh->nodes_gpu());
	// first element is the index of the intersected geometry and the second element is the distance to the intersection.
	
	// new positions = intersection points
	vec3 intersection_point = pos + p.second * dir;
    positions[i] = intersection_point;

    // Store the intersecting ray
    bvh->store_intersecting_ray(pos, intersection_point);

	
    // if a geometry was hit, p.first is its index and it updates the direction of the ray to the normal of the intersected geometry, 
    // otherwise p.first is -1.

	if (p.first >= 0) {
		if (nodes[p.first].type == NodeType::MESH) {
        // If it's a mesh, update the direction to the normal of the intersected triangle
        directions[i] = calculate_normal(nodes[p.first]);
    } else if (nodes[p.first].type == NodeType::NERF) {
        // If it's a NeRF, leave the direction unchanged for now
        // The actual NeRF tracing will be done later
    }
	}
}

}


